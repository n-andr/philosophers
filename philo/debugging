</--------------------LEFT------------------------->


int left_fork(t_philosopher *philo)
{
	pthread_mutex_lock(&philo->left_fork);
	if (philo->sim->fork_status[philo->id] == 0)
	{
		philo->sim->fork_status[philo->id] = 1;
		pthread_mutex_unlock(&philo->left_fork);
		pthread_mutex_lock(&philo->sim->print_lock);
		write_status("has taken a fork", philo);
		pthread_mutex_unlock(&philo->sim->print_lock);
		return (1);
	}
	pthread_mutex_unlock(&philo->left_fork);
	return (0);
}





</--------------------RIGHT------------------------->

int right_fork(t_philosopher *philo)
{
	int right_fork;

	right_fork = (philo->id + 1) % philo->sim->num_philo;
	pthread_mutex_lock(&philo->right_fork);
	if (philo->sim->fork_status[right_fork] == 0)
	{
		philo->sim->fork_status[right_fork] = 1;
		pthread_mutex_unlock(&philo->right_fork);
		pthread_mutex_lock(&philo->sim->print_lock);
		write_status("has taken a fork", philo);
		pthread_mutex_unlock(&philo->sim->print_lock);
		return (1);
	}
	pthread_mutex_unlock(&philo->right_fork);
	return (0);
}




</--------------------UNLOCK BOTH------------------------->



void eat(t_philosopher *philo)
{
    philo->last_meal_time = get_time() - philo->initiation_time;  // Update last meal time
    if (philo->times_eaten != -1)
		philo->times_eaten++;
	//pthread_mutex_lock(&philo->sim->print_lock); // maybe move to routine
    //write_status("is eating", philo);
	//pthread_mutex_unlock(&philo->sim->print_lock); // maybe move to routine
    //change usleep to sleep_good to check if philo is dead
	sleep_good(philo, philo->sim->time_to_eat, "is eating");
	//usleep(philo->sim->time_to_eat * 1000);  // Simulate eating
	//philo->last_meal_time = get_time();  // Update last meal time
	pthread_mutex_lock(&philo->left_fork);
	philo->sim->fork_status[philo->id] = 0;
	pthread_mutex_unlock(&philo->left_fork);
	pthread_mutex_lock(&philo->right_fork);
	philo->sim->fork_status[(philo->id + 1) % philo->sim->num_philo] = 0;
	pthread_mutex_unlock(&philo->right_fork);
}




</--------------------INITIALIZE------------------------->




int	create_philo(t_simulation *sim, t_philosopher *philo)
{
	int	i;

	i = 0;
	while (i < sim->num_philo)
	{
		philo[i].id = i;
		philo[i].times_eaten = 0;
		philo[i].initiation_time = get_time();
		philo[i].last_meal_time = get_time() - philo[i].initiation_time;
		philo[i].sim = sim;
		philo[i].left_fork = sim->forks[i];
		philo[i].right_fork = sim->forks[(i + 1) % sim->num_philo];
		i++;
	}
	return (1);
}
void init_forks(t_simulation *sim)
{
	int	i;

	i = 0;
	sim->fork_status = malloc(sizeof(int) * sim->num_philo);
	if (!sim->fork_status)
	{
		printf("Error: malloc failed\n");
		return ;
	}
	sim->forks = malloc(sizeof(pthread_mutex_t) * sim->num_philo);
	if (!sim->forks)
	{
		printf("Error: malloc failed\n");
		return ;
	}
	pthread_mutex_init(&sim->print_lock, NULL);
	pthread_mutex_init(&sim->dead_check_lock, NULL);
	while (i < sim->num_philo)
	{
		pthread_mutex_init(&sim->forks[i], NULL);
		sim->fork_status[i] = 0;
		i++;
	}
}














void eat(t_philosopher *philo)
{
    pthread_mutex_lock(&philo->left_fork);
    pthread_mutex_lock(&philo->right_fork);

    philo->last_meal_time = get_time() - philo->initiation_time;
    if (philo->times_eaten != -1)
        philo->times_eaten++;

    write_status("is eating", philo);  // Assuming write_status() is thread-safe
    sleep_good(philo, philo->sim->time_to_eat, "is eating");

    philo->sim->fork_status[philo->id] = 0;
    philo->sim->fork_status[(philo->id + 1) % philo->sim->num_philo] = 0;

    pthread_mutex_unlock(&philo->right_fork);
    pthread_mutex_unlock(&philo->left_fork);
}